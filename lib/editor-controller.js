"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorController = void 0;
const Atom = require("atom");
const rx = require("./regex");
const selectors = [
    'identifier.haskell',
    'entity.name.type.haskell',
    'entity.name.tag.haskell',
];
const operatorSelectors = [
    'keyword.operator.haskell',
    'entity.name.function.infix.haskell',
];
const activationScopes = ['source.haskell', 'text.tex.latex.haskell'];
const knownIdentClass = 'syntax--known-identifier';
class EditorController {
    constructor(editor, cb) {
        this.editor = editor;
        this.cb = cb;
        this.disposed = false;
        this.disposables = new Atom.CompositeDisposable();
        this.layer = this.editor.addMarkerLayer();
        this.disposables.add(this.editor.getBuffer().onDidChangeText((arg) => {
            handlePromise(this.didChangeText(arg));
        }));
        this.disposables.add(editor.onDidDestroy(() => {
            this.dispose();
        }));
        this.init();
    }
    static shouldActivate(ed) {
        return activationScopes.includes(ed.getGrammar().scopeName);
    }
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.layer.destroy();
            this.disposables.dispose();
        }
    }
    async init() {
        this.updateHighlightInRange(await this.getSymbols(), this.editor.getBuffer().getRange());
    }
    async didChangeText({ changes }) {
        const buffer = this.editor.getBuffer();
        const sbs = await this.getSymbols();
        for (const { newRange, oldRange } of changes) {
            for (const row of newRange.union(oldRange).getRows()) {
                this.updateHighlightInRange(sbs, buffer.rangeForRow(row));
            }
        }
    }
    updateHighlightInRange(sbs, searchRange) {
        for (const marker of this.layer.findMarkers({
            intersectsBufferRange: searchRange,
        })) {
            marker.destroy();
        }
        const buffer = this.editor.getBuffer();
        const range = Atom.Range.fromObject(searchRange);
        const decorate = (idents, selectors) => {
            for (const ident of idents) {
                if (sbs.has(buffer.getTextInRange(ident))) {
                    this.decorateRange(ident, selectors);
                }
            }
        };
        handlePromise(buffer
            .findAllInRange(rx.identRx, range)
            .then((idents) => decorate(idents, selectors)));
        handlePromise(buffer
            .findAllInRange(rx.operatorRx, range)
            .then((ops) => decorate(ops, operatorSelectors)));
    }
    async getSymbols() {
        const symbols = await this.cb.getCompletionsForSymbol(this.editor.getBuffer(), '', Atom.Point.fromObject([0, 0]));
        return new Set(symbols.map(({ qname }) => qname));
    }
    decorateRange(range, myselectors) {
        const [inScope] = this.editor
            .scopeDescriptorForBufferPosition(range.start)
            .getScopesArray()
            .filter((sel) => myselectors.includes(sel));
        if (inScope) {
            const srange = this.editor.bufferRangeForScopeAtPosition(inScope, range.start);
            const marker = this.layer.markBufferRange(srange || range, {
                invalidate: 'never',
            });
            this.editor.decorateMarker(marker, {
                type: 'text',
                class: knownIdentClass,
            });
        }
    }
}
exports.EditorController = EditorController;
function handlePromise(p) {
    p.catch(function (e) {
        atom.notifications.addError(`Something went wrong in language-haskell-scoped: ${e.name}`, {
            detail: e.message,
            stack: e.stack,
            dismissable: true,
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRpdG9yLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZWRpdG9yLWNvbnRyb2xsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQTRCO0FBQzVCLDhCQUE2QjtBQUc3QixNQUFNLFNBQVMsR0FBRztJQUNoQixvQkFBb0I7SUFDcEIsMEJBQTBCO0lBQzFCLHlCQUF5QjtDQUMxQixDQUFBO0FBRUQsTUFBTSxpQkFBaUIsR0FBRztJQUN4QiwwQkFBMEI7SUFDMUIsb0NBQW9DO0NBQ3JDLENBQUE7QUFFRCxNQUFNLGdCQUFnQixHQUFHLENBQUMsZ0JBQWdCLEVBQUUsd0JBQXdCLENBQUMsQ0FBQTtBQUVyRSxNQUFNLGVBQWUsR0FBRywwQkFBMEIsQ0FBQTtBQUVsRCxNQUFhLGdCQUFnQjtJQUszQixZQUFvQixNQUF1QixFQUFVLEVBQXNCO1FBQXZELFdBQU0sR0FBTixNQUFNLENBQWlCO1FBQVUsT0FBRSxHQUFGLEVBQUUsQ0FBb0I7UUFKbkUsYUFBUSxHQUFHLEtBQUssQ0FBQTtRQUVoQixnQkFBVyxHQUFHLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUE7UUFHbEQsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFBO1FBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzlDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7UUFDeEMsQ0FBQyxDQUFDLENBQ0gsQ0FBQTtRQUNELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUNsQixNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRTtZQUN2QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUE7UUFDaEIsQ0FBQyxD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QUMsQ0FBQyxJQUFJLEVBQUUsRUFDNUQ7WUFDRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU87WUFDakIsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLO1lBQ2QsV0FBVyxFQUFFLElBQUk7U0FDbEIsQ0FDRixDQUFBO0lBQ0gsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXRvbSBmcm9tICdhdG9tJ1xuaW1wb3J0ICogYXMgcnggZnJvbSAnLi9yZWdleCdcbmltcG9ydCB7IElDb21wbGV0aW9uQmFja2VuZCB9IGZyb20gJ2F0b20taGFza2VsbC11cGkvY29tcGxldGlvbi1iYWNrZW5kJ1xuXG5jb25zdCBzZWxlY3RvcnMgPSBbXG4gICdpZGVudGlmaWVyLmhhc2tlbGwnLFxuICAnZW50aXR5Lm5hbWUudHlwZS5oYXNrZWxsJyxcbiAgJ2VudGl0eS5uYW1lLnRhZy5oYXNrZWxsJyxcbl1cblxuY29uc3Qgb3BlcmF0b3JTZWxlY3RvcnMgPSBbXG4gICdrZXl3b3JkLm9wZXJhdG9yLmhhc2tlbGwnLFxuICAnZW50aXR5Lm5hbWUuZnVuY3Rpb24uaW5maXguaGFza2VsbCcsXG5dXG5cbmNvbnN0IGFjdGl2YXRpb25TY29wZXMgPSBbJ3NvdXJjZS5oYXNrZWxsJywgJ3RleHQudGV4LmxhdGV4Lmhhc2tlbGwnXVxuXG5jb25zdCBrbm93bklkZW50Q2xhc3MgPSAnc3ludGF4LS1rbm93bi1pZGVudGlmaWVyJ1xuXG5leHBvcnQgY2xhc3MgRWRpdG9yQ29udHJvbGxlciB7XG4gIHByaXZhdGUgZGlzcG9zZWQgPSBmYWxzZVxuICBwcml2YXRlIGxheWVyOiBBdG9tLkRpc3BsYXlNYXJrZXJMYXllclxuICBwcml2YXRlIGRpc3Bvc2FibGVzID0gbmV3IEF0b20uQ29tcG9zaXRlRGlzcG9zYWJsZSgpXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlZGl0b3I6IEF0b20uVGV4dEVkaXRvciwgcHJpdmF0ZSBjYjogSUNvbXBsZXRpb25CYWNrZW5kKSB7XG4gICAgdGhpcy5sYXllciA9IHRoaXMuZWRpdG9yLmFkZE1hcmtlckxheWVyKClcbiAgICB0aGlzLmRpc3Bvc2FibGVzLmFkZChcbiAgICAgIHRoaXMuZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCgoYXJnKSA9PiB7XG4gICAgICAgIGhhbmRsZVByb21pc2UodGhpcy5kaWRDaGFuZ2VUZXh0KGFyZykpXG4gICAgICB9KSxcbiAgICApXG4gICAgdGhpcy5kaXNwb3NhYmxlcy5hZGQoXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKClcbiAgICAgIH0pLFxuICAgIClcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLmluaXQoKVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBzaG91bGRBY3RpdmF0ZShlZDogQXRvbS5UZXh0RWRpdG9yKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFjdGl2YXRpb25TY29wZXMuaW5jbHVkZXMoZWQuZ2V0R3JhbW1hcigpLnNjb3BlTmFtZSlcbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5kaXNwb3NlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWVcbiAgICAgIHRoaXMubGF5ZXIuZGVzdHJveSgpXG4gICAgICB0aGlzLmRpc3Bvc2FibGVzLmRpc3Bvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdCgpIHtcbiAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodEluUmFuZ2UoXG4gICAgICBhd2FpdCB0aGlzLmdldFN5bWJvbHMoKSxcbiAgICAgIHRoaXMuZWRpdG9yLmdldEJ1ZmZlcigpLmdldFJhbmdlKCksXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkaWRDaGFuZ2VUZXh0KHsgY2hhbmdlcyB9OiBBdG9tLkJ1ZmZlclN0b3BwZWRDaGFuZ2luZ0V2ZW50KSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5lZGl0b3IuZ2V0QnVmZmVyKClcbiAgICBjb25zdCBzYnMgPSBhd2FpdCB0aGlzLmdldFN5bWJvbHMoKVxuICAgIGZvciAoY29uc3QgeyBuZXdSYW5nZSwgb2xkUmFuZ2UgfSBvZiBjaGFuZ2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBuZXdSYW5nZS51bmlvbihvbGRSYW5nZSkuZ2V0Um93cygpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0SW5SYW5nZShzYnMsIGJ1ZmZlci5yYW5nZUZvclJvdyhyb3cpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGlnaGxpZ2h0SW5SYW5nZShcbiAgICBzYnM6IFNldDxzdHJpbmc+LFxuICAgIHNlYXJjaFJhbmdlOiBBdG9tLlJhbmdlQ29tcGF0aWJsZSxcbiAgKSB7XG4gICAgZm9yIChjb25zdCBtYXJrZXIgb2YgdGhpcy5sYXllci5maW5kTWFya2Vycyh7XG4gICAgICBpbnRlcnNlY3RzQnVmZmVyUmFuZ2U6IHNlYXJjaFJhbmdlLFxuICAgIH0pKSB7XG4gICAgICBtYXJrZXIuZGVzdHJveSgpXG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuZWRpdG9yLmdldEJ1ZmZlcigpXG4gICAgY29uc3QgcmFuZ2UgPSBBdG9tLlJhbmdlLmZyb21PYmplY3Qoc2VhcmNoUmFuZ2UpXG5cbiAgICBjb25zdCBkZWNvcmF0ZSA9IChpZGVudHM6IEF0b20uUmFuZ2VMaWtlW10sIHNlbGVjdG9yczogc3RyaW5nW10pID0+IHtcbiAgICAgIGZvciAoY29uc3QgaWRlbnQgb2YgaWRlbnRzKSB7XG4gICAgICAgIGlmIChzYnMuaGFzKGJ1ZmZlci5nZXRUZXh0SW5SYW5nZShpZGVudCkpKSB7XG4gICAgICAgICAgdGhpcy5kZWNvcmF0ZVJhbmdlKGlkZW50LCBzZWxlY3RvcnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVQcm9taXNlKFxuICAgICAgYnVmZmVyXG4gICAgICAgIC5maW5kQWxsSW5SYW5nZShyeC5pZGVudFJ4LCByYW5nZSlcbiAgICAgICAgLnRoZW4oKGlkZW50cykgPT4gZGVjb3JhdGUoaWRlbnRzLCBzZWxlY3RvcnMpKSxcbiAgICApXG5cbiAgICBoYW5kbGVQcm9taXNlKFxuICAgICAgYnVmZmVyXG4gICAgICAgIC5maW5kQWxsSW5SYW5nZShyeC5vcGVyYXRvclJ4LCByYW5nZSlcbiAgICAgICAgLnRoZW4oKG9wcykgPT4gZGVjb3JhdGUob3BzLCBvcGVyYXRvclNlbGVjdG9ycykpLFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3ltYm9scygpIHtcbiAgICBjb25zdCBzeW1ib2xzID0gYXdhaXQgdGhpcy5jYi5nZXRDb21wbGV0aW9uc0ZvclN5bWJvbChcbiAgICAgIHRoaXMuZWRpdG9yLmdldEJ1ZmZlcigpLFxuICAgICAgJycsXG4gICAgICBBdG9tLlBvaW50LmZyb21PYmplY3QoWzAsIDBdKSxcbiAgICApXG4gICAgcmV0dXJuIG5ldyBTZXQoc3ltYm9scy5tYXAoKHsgcW5hbWUgfSkgPT4gcW5hbWUpKVxuICB9XG5cbiAgcHJpdmF0ZSBkZWNvcmF0ZVJhbmdlKHJhbmdlOiBBdG9tLlJhbmdlTGlrZSwgbXlzZWxlY3RvcnM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgW2luU2NvcGVdID0gdGhpcy5lZGl0b3JcbiAgICAgIC5zY29wZURlc2NyaXB0b3JGb3JCdWZmZXJQb3NpdGlvbihyYW5nZS5zdGFydClcbiAgICAgIC5nZXRTY29wZXNBcnJheSgpXG4gICAgICAuZmlsdGVyKChzZWwpID0+IG15c2VsZWN0b3JzLmluY2x1ZGVzKHNlbCkpXG4gICAgaWYgKGluU2NvcGUpIHtcbiAgICAgIGNvbnN0IHNyYW5nZSA9IHRoaXMuZWRpdG9yLmJ1ZmZlclJhbmdlRm9yU2NvcGVBdFBvc2l0aW9uKFxuICAgICAgICBpblNjb3BlLFxuICAgICAgICByYW5nZS5zdGFydCxcbiAgICAgIClcbiAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMubGF5ZXIubWFya0J1ZmZlclJhbmdlKHNyYW5nZSB8fCByYW5nZSwge1xuICAgICAgICBpbnZhbGlkYXRlOiAnbmV2ZXInLFxuICAgICAgfSlcbiAgICAgIC8vIEB0cy1pZ25vcmUgLy8gVE9ETzogY29tcGxhaW4gb24gRFRcbiAgICAgIHRoaXMuZWRpdG9yLmRlY29yYXRlTWFya2VyKG1hcmtlciwge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGNsYXNzOiBrbm93bklkZW50Q2xhc3MsXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVQcm9taXNlKHA6IFByb21pc2U8dm9pZD4pOiB2b2lkIHtcbiAgcC5jYXRjaChmdW5jdGlvbihlOiBFcnJvcikge1xuICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcihcbiAgICAgIGBTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBsYW5ndWFnZS1oYXNrZWxsLXNjb3BlZDogJHtlLm5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgZGV0YWlsOiBlLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlLnN0YWNrLFxuICAgICAgICBkaXNtaXNzYWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgKVxuICB9KVxufVxuIl19